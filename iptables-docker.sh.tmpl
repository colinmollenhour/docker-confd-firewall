#!/bin/bash
# 
# Colin Mollenhour
# 
# This script outputs iptables rules compatible with iptables-restore.
# The rules are designed to block traffic that is not from whitelisted
# addresses which is destined for a published docker container port.
#
# Expects the following environment variables set in confd scope:
#  - FW_MODE      either 'docker' for DOCKER-USER rules, or 'host' for INPUT
#  - FW_GRIDS     comma-separated list of grids to enumerate nodes from
#  - FW_SERVICE   friendly name for the service
#  - FW_PROTO     protocol to allow (tcp|udp)
#  - FW_PORTS     comma-separated list of port numbers to allow
#
# Optional:
#  - FW_STATIC    comma-separated list of IPs to always allow
#  - FW_DENY      deny behavior - e.g. DROP or REJECT (default: REJECT)
#
# Example:
#  $ iptables.sh | iptables-restore --counters --noflush

# Get public interface name
IF=$(ip route | awk '/^default/{print $5}')

mode={{getenv "FW_MODE"}}
service={{getenv "FW_SERVICE"}}
protos={{getenv "FW_PROTO"}}
ports={{getenv "FW_PORTS"}}
static={{getenv "FW_STATIC"}}
deny={{getenv "FW_DENY"}}

[ -n "$service" ] || { echo "Service is not set."; exit 1; }
[ -n "$protos" ] || { echo "Protocol is not set."; exit 1; }
[ -n "$ports" ] || { echo "Ports is not set."; exit 1; }
[ -n "$deny" ] || deny=REJECT
[ "$deny" = "REJECT" ] && deny="REJECT --reject-with icmp-port-unreachable"

case "$mode" in
  docker)
    target=DOCKER-USER
    prefix=DOCKER-USER-$service
    chain=$prefix-$(openssl rand 3 -hex)
  ;;
  host)
    target=INPUT
    prefix=DOCKER-HOST-$service
    chain=$prefix-$(openssl rand 3 -hex)
  ;;
  *)
    echo "Mode is invalid: '$mode'"
    exit 1
  ;;
esac

echo "# Generated by iptables.sh: $service $protos $ports"
echo "# Public interface: $IF"
iptables-save -t filter | sed "/$prefix-/d;/^COMMIT$/d;/^#/d"

# Allow the firewall to be disabled
if [[ "{{getenv "FW_DISABLE"}}" = "1" ]]; then
  echo COMMIT
  exit 0
fi

# Add new chain
echo -N ${chain}

# Allow related and established
echo -A ${chain} -m conntrack --ctstate RELATED,ESTABLISHED -j RETURN

# Allow source IPs
# Example: echo -A ${chain} -s 10.10.10.10 -j RETURN -m comment --comment "primary:test3.local.lan::"
for addr in ${static//,/ }; do
  echo -A ${chain} -s ${addr} -j RETURN -m comment --comment "static-entry"
done
# Dynamically generated entries
{{if eq (getenv "FW_GRIDS") "*"}}
  {{range $grid := ls "/mirror/v1"}}
    {{range ls (printf "/mirror/v1/%s" $grid)}}
echo -A ${chain} -s {{getv (printf "/mirror/v1/%s/%s" $grid .)}} -j RETURN -m comment --comment "{{$grid}}:{{.}}::"
    {{end}}
  {{end}}
{{else if ne (getenv "FW_GRIDS") ""}}
  {{range $grid := split (getenv "FW_GRIDS") ","}}
    {{range ls (printf "/mirror/v1/%s" $grid)}}
echo -A ${chain} -s {{getv (printf "/mirror/v1/%s/%s" $grid .)}} -j RETURN -m comment --comment "{{$grid}}:{{.}}::"
    {{end}}
  {{end}}
{{end}}

# Deny all other IPs
echo -A ${chain} -j $deny

# Insert rule into DOCKER-USER
for proto in ${protos//,/$'\n'}; do
  for port in ${ports//,/$'\n'}; do
    echo -I $target -i $IF -p ${proto} -m ${proto} --dport ${port} -j ${chain}
  done
done

echo COMMIT
echo "# Complete"
